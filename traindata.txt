add
add and
add and and store in
add and and store it in
add and and store result in
add and and store in register
add and and store it in register
add and and store it result in register
add in
copy to
update to point to
update by
increment by
update using
using update 
do addition of and
perform addition of and
plus
perform plus
do plus
add with
update to point to next element
add
add and
add and and store in
add and and store it in
add and and store result in
add and and store in register
add and and store it in register
add and and store it result in register
add in 
update by
add the value of with
increment by
decrement by
increment
decrement
update by constant
Add and and store the result in register
give result of and by AND gate 
using and gate give result of and
anding with
perform and operation of and and store it in
perform and operation of and and store result in register
perform and operation of and and store result in
give result of $s1 and constant by AND gate
	using AND gate give result of $s1 and constant
	$s1 anding with any constant
BEQ:-	jump if branch result is equal
	jump if branch both answer are same 
	jump if branch result is same 
	jump if branch both answer are not different
	jump if branch answer same
	jump if branch answer equal
	jump if branch same result
	jump if branch same answer
	jump if branch result is equal
	jump if branch both answer are same
	jump to lable if branch result is same 
	jump to lable if branch both answer are not different
	jump to lable if branch answer same
	jump to lable if branch answer equal
	jump to lable if branch same result
	jump to lable if branch same answer
BLTZ:-	jump if branch less than zero
	jump if branch not more than zero
	jump to lable if branch less than zero
	jump to lable if branch not more than zero
BNE:-	jump to lable if branch $s1 is not equal to $s2
	jump if branch is not equal
DIV:-	Divides $s by $t
	division of $s and $t
J:-	go to loop
	jump if 
	create loop using jump
LB:-	load byte in resister
LW:-	fetch s1
	load value $s1
	load value of
MFHI:-	move the result in high resister
	contains of resister HI are moved in specific resister
MFLO:-	The contents of register LO are moved to the specified register
	move the result in LOW resister
MULT:-	s1 into s2
	multiply $s1 and $s2
	$s1 multiple with $s2
	do multiplication of $s1 and $s2
multu:-	Multiplies $s by $t and stores the result in $LO
NOR:-	give result of $s1 and $s2 by NOR gate 
	using NOR gate give result of $s1 and $s2
OR:-	give the result of $s1 and $s2 by using AND gate
	using AND gate give result of $s1 and $s2
	$s1 oring with $s2
ORI:-	give the result of $s1 and constant by using AND gate
	using AND gate give result of $s1 and constant
	$s1 oring with any constant
SB:-	store byte in resister
SLL:-	turn s1 into a byte offset  (sll $t0, $t0, 2)
	"i" as a byte offset
	shift left logicaly by constant
SLLV:-	shift variable
	variable shift
	shift left logically in variable
SLT:-	set less than by
	set less than zero
	set $t1 less than $t2
	set $t1 not more than or equal $t2
SLTI:-	set less than any constant
	set more than or equal any constant
SUB:-	subtract  $s1 and $s2
	do substraction of $s1 and $s2
	using $s1 substract $s2
	$s1 minus $s2
SUBU:-	Subtracts two registers and stores the result in a register
SW:-	store result in $t0
	store answer in $t0
	store the result
	using $t0 store value
XOR:-	give result of $s1 and $s2 by XOR gate 
	xoring of $s1 and $s2
	xoring of any two number using resister
	using xor gate give result of $s1 and $s2
XORI:-	give result of $s1 and constant by XOR gate 
	xoring of $s1 and constant
	using xor gate give result of $s1 and constant